'From Pharo1.3 of 16 June 2011 [Latest update: #13315] on 29 October 2011 at 3:52:13 pm'!Object subclass: #Point	instanceVariableNames: 'x y'	classVariableNames: ''	poolDictionaries: ''	category: 'Graphics-Primitives'!!Point commentStamp: '<historical>' prior: 0!I represent an x-y pair of numbers usually designating a location on the screen.!!Point methodsFor: '*Polymorph-Geometry' stamp: 'gvc 10/31/2006 11:01'!directionToLineFrom: p1 to: p2	"Answer the direction of the line from the receiver	position.	< 0 => left (receiver to right)	= => on line	> 0 => right (receiver to left)."	^((p2 x - p1 x) * (self y - p1 y)) -		((self x - p1 x) * (p2 y - p1 y))! !!Point methodsFor: '*Polymorph-Widgets' stamp: 'gvc 2/17/2008 13:36'!angle	"Answer the angle in radians between the vectors represented by	the receiver and (1, 0) from the origin."	^self y arcTan: self x! !!Point methodsFor: '*Polymorph-Widgets' stamp: 'gvc 2/17/2008 13:36'!angleWith: aPoint	"Answer the angle in radians between the vectors represented by	the receiver and aPoint from the origin."	|ar ap|	ar := self angle.	ap := aPoint angle.	^ap >= ar		ifTrue: [ap - ar]		ifFalse: [Float pi * 2 - ar + ap]! !!Point methodsFor: '*Polymorph-Widgets' stamp: 'gvc 10/12/2006 10:12'!max	"Answer a number that is the maximum	of the x and y of the receiver."	^self x max: self y! !!Point methodsFor: '*Polymorph-Widgets' stamp: 'gvc 10/12/2006 10:13'!min	"Answer a number that is the minimum	of the x and y of the receiver."	^self x min: self y! !!Point methodsFor: '*Polymorph-Widgets' stamp: 'gvc 2/17/2008 13:36'!reflectedAbout: aPoint	"Answer a new point that is the reflection of the receiver about the given point."	^(self - aPoint) negated + aPoint! !!Point methodsFor: 'accessing'!x	"Answer the x coordinate."	^x! !!Point methodsFor: 'accessing'!y	"Answer the y coordinate."	^y! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:01'!* arg 	"Answer a Point that is the product of the receiver and arg."	arg isPoint ifTrue: [^ (x * arg x) @ (y * arg y)].	^ arg adaptToPoint: self andSend: #*! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:01'!+ arg 	"Answer a Point that is the sum of the receiver and arg."	arg isPoint ifTrue: [^ (x + arg x) @ (y + arg y)].	^ arg adaptToPoint: self andSend: #+! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:02'!- arg 	"Answer a Point that is the difference of the receiver and arg."	arg isPoint ifTrue: [^ (x - arg x) @ (y - arg y)].	^ arg adaptToPoint: self andSend: #-! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:02'!/ arg 	"Answer a Point that is the quotient of the receiver and arg."	arg isPoint ifTrue: [^ (x / arg x) @ (y / arg y)].	^ arg adaptToPoint: self andSend: #/! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:02'!// arg 	"Answer a Point that is the quotient of the receiver and arg."	arg isPoint ifTrue: [^ (x // arg x) @ (y // arg y)].	^ arg adaptToPoint: self andSend: #//! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:02'!\\ arg 	"Answer a Point that is the mod of the receiver and arg."	arg isPoint ifTrue: [^ (x \\ arg x) @ (y \\ arg y)].	^ arg adaptToPoint: self andSend: #\\! !!Point methodsFor: 'arithmetic'!abs	"Answer a Point whose x and y are the absolute values of the receiver's x 	and y."	^ x abs @ y abs! !!Point methodsFor: 'arithmetic' stamp: 'TRee 6/3/2004 11:09'!reciprocal    " Answer a Point with coordinates that are the reciprocals of mine. "    " Method was missing from release. "    " 20040301 20:50:35 TRee(Squeak3.6-5429-tree07.38) "    ^ x reciprocal @ y reciprocal.! !!Point methodsFor: 'comparing'!< aPoint 	"Answer whether the receiver is above and to the left of aPoint."	^x < aPoint x and: [y < aPoint y]! !!Point methodsFor: 'comparing'!<= aPoint 	"Answer whether the receiver is neither below nor to the right of aPoint."	^x <= aPoint x and: [y <= aPoint y]! !!Point methodsFor: 'comparing'!= aPoint	self species = aPoint species		ifTrue: [^x = aPoint 	"Refer to the comment in Object|=." x and: [y = aPoint y]]		ifFalse: [^false]! !!Point methodsFor: 'comparing'!> aPoint 	"Answer whether the receiver is below and to the right of aPoint."	^x > aPoint x and: [y > aPoint y]! !!Point methodsFor: 'comparing'!>= aPoint 	"Answer whether the receiver is neither above nor to the left of aPoint."	^x >= aPoint x and: [y >= aPoint y]! !!Point methodsFor: 'comparing' stamp: 'Alexandre Bergel 8/2/2010 12:20'!closeTo: aPoint 	^ (x closeTo: aPoint x) and: [ y closeTo: aPoint y ]! !!Point methodsFor: 'comparing' stamp: 'SqR 11/3/2000 17:08'!hash	"Hash is reimplemented because = is implemented."	^(x hash hashMultiply + y hash) hashMultiply! !!Point methodsFor: 'comparing'!max: aPoint 	"Answer the lower right corner of the rectangle uniquely defined by the 	receiver and the argument, aPoint."	^ (x max: aPoint x) @ (y max: aPoint y)! !!Point methodsFor: 'comparing'!min: aPoint 	"Answer the upper left corner of the rectangle uniquely defined by the 	receiver and the argument, aPoint."	^ (x min: aPoint x) @ (y min: aPoint y)! !!Point methodsFor: 'comparing'!min: aMin max: aMax 	^ (self min: aMin) max: aMax! !!Point methodsFor: 'converting' stamp: 'di 11/6/1998 13:45'!adaptToCollection: rcvr andSend: selector	"If I am involved in arithmetic with a Collection, return a Collection of	the results of each element combined with me in that expression."	^ rcvr collect: [:element | element perform: selector with: self]! !!Point methodsFor: 'converting' stamp: 'di 11/9/1998 12:44'!adaptToNumber: rcvr andSend: selector	"If I am involved in arithmetic with an Integer, convert it to a Point."	^ rcvr @ rcvr perform: selector with: self! !!Point methodsFor: 'converting' stamp: 'di 11/6/1998 13:47'!adaptToString: rcvr andSend: selector	"If I am involved in arithmetic with a String, convert it to a Number."	^ rcvr asNumber perform: selector with: self! !!Point methodsFor: 'converting'!asFloatPoint	^ x asFloat @ y asFloat! !!Point methodsFor: 'converting'!asIntegerPoint	^ x asInteger @ y asInteger! !!Point methodsFor: 'converting' stamp: 'wiz 11/25/2004 12:48'!asNonFractionalPoint(x isFraction or: [y isFraction])	ifTrue:[^ x asFloat @ y asFloat]! !!Point methodsFor: 'converting'!asPoint	"Answer the receiver itself."	^self! !!Point methodsFor: 'converting'!corner: aPoint 	"Answer a Rectangle whose origin is the receiver and whose corner is 	aPoint. This is one of the infix ways of expressing the creation of a 	rectangle."	^Rectangle origin: self corner: aPoint! !!Point methodsFor: 'converting'!extent: aPoint 	"Answer a Rectangle whose origin is the receiver and whose extent is 	aPoint. This is one of the infix ways of expressing the creation of a 	rectangle."	^Rectangle origin: self extent: aPoint! !!Point methodsFor: 'converting' stamp: 'di 11/6/1998 07:45'!isPoint	^ true! !!Point methodsFor: 'converting' stamp: 'di 12/3/97 19:00'!rect: aPoint 	"Answer a Rectangle that encompasses the receiver and aPoint.	This is the most general infix way to create a rectangle."	^ Rectangle 		origin: (self min: aPoint)		corner: (self max: aPoint)! !!Point methodsFor: 'copying'!deepCopy	"Implemented here for better performance."	^x deepCopy @ y deepCopy! !!Point methodsFor: 'copying' stamp: 'tk 8/19/1998 16:05'!veryDeepCopyWith: deepCopier	"Return self.  I am immutable in the Morphic world.  Do not record me."! !!Point methodsFor: 'extent functions' stamp: 'wiz 8/9/2005 02:44'!guarded"Return a positive nonzero extent."self max: 1@1 .! !!Point methodsFor: 'extent functions' stamp: 'StephaneDucasse 5/27/2010 22:11'!scaleTo: anExtent	"Return a Point scalefactor for shrinking a thumbnail of the receiver's extent to fit within anExtent"	" self and anExtent are expected to have positive nonZero x and y. "	|  factor  sX sY | 	factor :=  3.0  reciprocal . "EccentricityThreshhold reciprical"	sX := anExtent x / self  x asFloat  .	sY :=  anExtent y / self  y asFloat  .	sX = sY ifTrue: [ ^ sX @ sY ] . "Same aspect ratio"	^ sX < sY 		ifTrue: [ sX @ (sX max: sY * factor) ] 		ifFalse: [ (sY max: sX * factor ) @ sY  ] ! !!Point methodsFor: 'geometry' stamp: 'laza 1/24/2000 03:44'!isInsideCircle: a with: b with: c 	"Returns TRUE if self is inside the circle defined by the     	points a, b, c. See Guibas and Stolfi (1985) p.107"	^ (a dotProduct: a)		* (b triangleArea: c with: self) - ((b dotProduct: b)			* (a triangleArea: c with: self)) + ((c dotProduct: c)			* (a triangleArea: b with: self)) - ((self dotProduct: self)			* (a triangleArea: b with: c)) > 0.0! !!Point methodsFor: 'geometry' stamp: 'lr 7/4/2009 10:42'!sideOf: otherPoint 	"Returns #left, #right or #center if the otherPoint lies to the left, right 	or on the line given by the vector from 0@0 to self"	| side |	side := (self crossProduct: otherPoint) sign.	^ {  #right. #center. #left  } at: side + 2! !!Point methodsFor: 'geometry' stamp: 'lr 7/4/2009 10:42'!to: end1 intersects: start2 to: end2 	"Returns true if the linesegment from start1 (=self) to end1 intersects      	    with the segment from start2 to end2, otherwise false."	| start1 sideStart sideEnd |	start1 := self.	(((start1 = start2 or: [ end1 = end2 ]) or: [ start1 = end2 ]) or: [ start2 = end1 ]) ifTrue: [ ^ true ].	sideStart := start1 		to: end1		sideOf: start2.	sideEnd := start1 		to: end1		sideOf: end2.	sideStart = sideEnd ifTrue: [ ^ false ].	sideStart := start2 		to: end2		sideOf: start1.	sideEnd := start2 		to: end2		sideOf: end1.	sideStart = sideEnd ifTrue: [ ^ false ].	^ true! !!Point methodsFor: 'geometry' stamp: 'laza 1/5/2000 11:50'!to: end sideOf: otherPoint 	"Returns #left, #right, #center if the otherPoint lies to the left, right or on the line given by the vector from self to end"	^ end - self sideOf: otherPoint - self! !!Point methodsFor: 'geometry' stamp: 'laza 1/17/2000 15:47'!triangleArea: b with: c	"Returns twice the area of the oriented triangle (a, b, c), i.e., the   	area is positive if the triangle is oriented counterclockwise"	^ b x - self x * (c y - self y) - (b y - self y * (c x - self x))! !!Point methodsFor: 'interpolating' stamp: 'jsp 3/22/1999 16:31'!interpolateTo: end at: amountDone	"Interpolate between the instance and end after the specified amount has been done (0 - 1)."	^ self + ((end - self) * amountDone).! !!Point methodsFor: 'point functions' stamp: 'FBS 1/5/2004 13:08'!bearingToPoint: anotherPoint    "Return the bearing, in degrees, from the receiver to anotherPoint.     Adapted from Playground, where the ultimate provenance of the algorithm was a wild earlier method of Jay Fenton's which I never checked carefully, but the thing has always seemed to work"    | deltaX deltaY  |    deltaX := anotherPoint x -  x.    deltaY := anotherPoint y - y.    deltaX abs < 0.001        ifTrue:            [^ deltaY > 0 ifTrue: [180] ifFalse: [0]].    ^ ((deltaX >= 0 ifTrue: [90] ifFalse: [270])            - ((deltaY / deltaX) arcTan negated radiansToDegrees)) rounded! !!Point methodsFor: 'point functions' stamp: 'ar 10/30/1998 03:05'!crossProduct: aPoint 	"Answer a number that is the cross product of the receiver and the 	argument, aPoint."	^ (x * aPoint y) - (y * aPoint x)! !!Point methodsFor: 'point functions' stamp: 'lr 7/4/2009 10:42'!dist: aPoint 	"Answer the distance between aPoint and the receiver."	| dx dy |	dx := aPoint x - x.	dy := aPoint y - y.	^ (dx * dx + (dy * dy)) sqrt! !!Point methodsFor: 'point functions' stamp: 'di 9/11/1998 16:22'!dotProduct: aPoint 	"Answer a number that is the dot product of the receiver and the 	argument, aPoint. That is, the two points are multipled and the 	coordinates of the result summed."	^ (x * aPoint x) + (y * aPoint y)! !!Point methodsFor: 'point functions' stamp: 'StephaneDucasse 7/7/2010 23:58'!eightNeighbors	^ { self + (1 @ 0) . self + (1 @ 1) .  self + (0 @ 1) . self + (-1 @ 1) . self + (-1 @ 0) .		 self + (-1 @ -1) . self + (0 @ -1) . self + (1 @ -1)}! !!Point methodsFor: 'point functions' stamp: 'di 6/11/97 16:08'!flipBy: direction centerAt: c	"Answer a Point which is flipped according to the direction about the point c.	Direction must be #vertical or #horizontal."	direction == #vertical ifTrue: [^ x @ (c y * 2 - y)].	direction == #horizontal ifTrue: [^ (c x * 2 - x) @ y].	self error: 'unrecognizable direction'! !!Point methodsFor: 'point functions' stamp: 'StephaneDucasse 7/7/2010 23:40'!fourDirections	"Return vertices for a square centered at 0 asPoint with the receiver as first corner.	Returns the four rotation of the reciever in counter clockwise order with the receiver appearing last."		^ Array with: self leftRotated			with: self negated			with: self rightRotated			with: self 		! !!Point methodsFor: 'point functions' stamp: 'nice 3/5/2010 22:39'!fourNeighbors	^ Array with: self + (1 @ 0)		with: self + (0 @ 1)		with: self + (-1 @ 0)		with: self + (0 @ -1)! !!Point methodsFor: 'point functions' stamp: 'lr 7/4/2009 10:42'!grid: aPoint 	"Answer a Point to the nearest rounded grid modules specified by aPoint."	| newX newY |	newX := x + (aPoint x // 2) truncateTo: aPoint x.	newY := y + (aPoint y // 2) truncateTo: aPoint y.	^ newX @ newY! !!Point methodsFor: 'point functions' stamp: 'lr 7/4/2009 10:42'!insideTriangle: p1 with: p2 with: p3 	"Return true if the receiver is within the triangle defined by the three coordinates.	Note: This method computes the barycentric coordinates for the receiver and tests those coordinates."	| p0 b0 b1 b2 b3 |	p0 := self.	b0 := (p2 x - p1 x) * (p3 y - p1 y) - ((p3 x - p1 x) * (p2 y - p1 y)).	b0 isZero ifTrue: [ ^ false ].	"degenerate"	b0 := 1.0 / b0.	b1 := ((p2 x - p0 x) * (p3 y - p0 y) - ((p3 x - p0 x) * (p2 y - p0 y))) * b0.	b2 := ((p3 x - p0 x) * (p1 y - p0 y) - ((p1 x - p0 x) * (p3 y - p0 y))) * b0.	b3 := ((p1 x - p0 x) * (p2 y - p0 y) - ((p2 x - p0 x) * (p1 y - p0 y))) * b0.	b1 < 0.0 ifTrue: [ ^ false ].	b2 < 0.0 ifTrue: [ ^ false ].	b3 < 0.0 ifTrue: [ ^ false ].	^ true! !!Point methodsFor: 'point functions' stamp: 'StephaneDucasse 7/7/2010 23:39'!leftRotated	"Return the receiver rotated 90 degrees. i.e., self rotateBy: #left centerAt: 0 asPoint.Compare to transposed and normal."	^y  @ x negated! !!Point methodsFor: 'point functions' stamp: 'lr 7/4/2009 10:42'!nearestPointAlongLineFrom: p1 to: p2 	"Note this will give points beyond the endpoints.	Streamlined by Gerardo Richarte 11/3/97"	| x21 y21 t x1 y1 |	p1 x = p2 x ifTrue: [ ^ p1 x @ y ].	p1 y = p2 y ifTrue: [ ^ x @ p1 y ].	x1 := p1 x asFloat.	y1 := p1 y asFloat.	x21 := p2 x asFloat - x1.	y21 := p2 y asFloat - y1.	t := ((y asFloat - y1) / x21 + ((x asFloat - x1) / y21)) / (x21 / y21 + (y21 / x21)).	^ (x1 + (t * x21)) @ (y1 + (t * y21))	"	| old new |	Pen new place: 200@100; goto: (old := 500@300).	Display reverse: (old extent: 10@10).	[Sensor anyButtonPressed] whileFalse:		[(new := (Sensor cursorPoint nearestPointAlongLineFrom: 200@100 to: 500@300) )			= old ifFalse:				[Display reverse: (old extent: 10@10).				Display reverse: ((old := new) extent: 10@10)]]"! !!Point methodsFor: 'point functions' stamp: 'di 12/1/97 12:40'!nearestPointOnLineFrom: p1 to: p2	"This will not give points beyond the endpoints"	^ (self nearestPointAlongLineFrom: p1 to: p2)		adhereTo: (p1 rect: p2)! !!Point methodsFor: 'point functions' stamp: 'StephaneDucasse 7/7/2010 23:42'!normal	"Answer a Point representing the unit vector rotated 90 deg clockwise. For the zero point return -1@0."	| n d |	n := y negated @ x.	(d := (n x * n x + (n y * n y))) = 0		 ifTrue: [ ^ -1 @0].	^n / d sqrt! !!Point methodsFor: 'point functions' stamp: 'lr 7/4/2009 10:42'!normalized	"Optimized for speed -- ar 8/26/2001"	| r |	r := (x * x + (y * y)) sqrt.	^ (x / r) @ (y / r)! !!Point methodsFor: 'point functions' stamp: 'lr 7/4/2009 10:42'!octantOf: otherPoint 	"Return 1..8 indicating relative direction to otherPoint.  	1=ESE, 2=SSE, ... etc. clockwise to 8=ENE"	"[Sensor anyButtonPressed] whileFalse: [(Display boundingBox center 	octantOf: Sensor cursorPoint) printString displayAt: 0@0]"	| quad moreHoriz |	(x = otherPoint x and: [ y > otherPoint y ]) ifTrue: [ ^ 6 ].	"special case"	(y = otherPoint y and: [ x < otherPoint x ]) ifTrue: [ ^ 8 ].	quad := self quadrantOf: otherPoint.	moreHoriz := (x - otherPoint x) abs >= (y - otherPoint y) abs.	(quad even eqv: moreHoriz) 		ifTrue: [ ^ quad * 2 ]		ifFalse: [ ^ quad * 2 - 1 ]! !!Point methodsFor: 'point functions' stamp: 'di 12/1/97 12:12'!onLineFrom: p1 to: p2	^ self onLineFrom: p1 to: p2 within: 2! !!Point methodsFor: 'point functions' stamp: 'jm 2/24/98 08:34'!onLineFrom: p1 to: p2 within: epsilon	"Answer true if the receiver lies on the given line segment between p1 and p2 within a small epsilon."	"is this point within the box spanning p1 and p2 expanded by epsilon? (optimized)"	p1 x < p2 x		ifTrue: [			((x < (p1 x - epsilon)) or: [x > (p2 x + epsilon)]) ifTrue: [^ false]]		ifFalse: [			((x < (p2 x - epsilon)) or: [x > (p1 x + epsilon)]) ifTrue: [^ false]].	p1 y < p2 y		ifTrue: [			((y < (p1 y - epsilon)) or: [y > (p2 y + epsilon)]) ifTrue: [^ false]]		ifFalse: [			((y < (p2 y - epsilon)) or: [y > (p1 y + epsilon)]) ifTrue: [^ false]].	"it's in the box; is it on the line?"	^ (self dist: (self nearestPointAlongLineFrom: p1 to: p2)) <= epsilon! !!Point methodsFor: 'point functions' stamp: '6/9/97 14:51 di'!quadrantOf: otherPoint	"Return 1..4 indicating relative direction to otherPoint.	1 is downRight, 2=downLeft, 3=upLeft, 4=upRight"	^ x <= otherPoint x		ifTrue: [y < otherPoint y ifTrue: [1] ifFalse: [4]]		ifFalse: [y <= otherPoint y ifTrue: [2] ifFalse: [3]]"[Sensor anyButtonPressed] whileFalse:	[(Display boundingBox center quadrantOf: Sensor cursorPoint) printString displayAt: 0@0]"! !!Point methodsFor: 'point functions' stamp: 'StephaneDucasse 7/7/2010 23:38'!rightRotated	"Return the receiver rotated 90 degrees, i.e. self rotateBy: #right centerAt: 0 asPoint. Compare to transposed and normal."	^y negated @ x! !!Point methodsFor: 'point functions' stamp: 'lr 7/4/2009 10:42'!rotateBy: direction centerAt: c 	"Answer a Point which is rotated according to direction, about the point c.	Direction must be one of #right (CW), #left (CCW) or #pi (180 degrees)."	| offset |	offset := self - c.	direction == #right ifTrue: [ ^ offset y negated @ offset x + c ].	direction == #left ifTrue: [ ^ offset y @ offset x negated + c ].	direction == #pi ifTrue: [ ^ c - offset ].	self error: 'unrecognizable direction'! !!Point methodsFor: 'point functions' stamp: 'StephaneDucasse 7/7/2010 23:38'!sign	^ (x sign @ y sign)! !!Point methodsFor: 'point functions' stamp: 'ar 4/18/1999 05:17'!sortsBefore: otherPoint	"Return true if the receiver sorts before the other point"	^y = otherPoint y		ifTrue:[x <= otherPoint x]		ifFalse:[y <= otherPoint y]! !!Point methodsFor: 'point functions' stamp: 'lr 7/4/2009 10:42'!squaredDistanceTo: aPoint 	"Answer the distance between aPoint and the receiver."	| delta |	delta := aPoint - self.	^ delta dotProduct: delta! !!Point methodsFor: 'point functions' stamp: 'ar 11/12/1998 01:44'!transposed	^y @ x! !!Point methodsFor: 'polar coordinates' stamp: 'lr 7/4/2009 10:42'!degrees	"Answer the angle the receiver makes with origin in degrees. right is 0; down is 90."	| tan theta |	x = 0 		ifTrue: 			[ y >= 0 				ifTrue: [ ^ 90.0 ]				ifFalse: [ ^ 270.0 ] ]		ifFalse: 			[ tan := y asFloat / x asFloat.			theta := tan arcTan.			x >= 0 				ifTrue: 					[ y >= 0 						ifTrue: [ ^ theta radiansToDegrees ]						ifFalse: [ ^ 360.0 + theta radiansToDegrees ] ]				ifFalse: [ ^ 180.0 + theta radiansToDegrees ] ]! !!Point methodsFor: 'polar coordinates'!r	"Answer the receiver's radius in polar coordinate system."	^(self dotProduct: self) sqrt! !!Point methodsFor: 'polar coordinates' stamp: 'hk 11/10/2005 10:07'!theta	"Answer the angle the receiver makes with origin in radians. right is 0; 	down is 90. 	Corrected the constants from single precision to 64 Bit precision 	and changed the sends in case of overflow to constants HK 2005-07-23"	| tan theta |	x = 0		ifTrue: [y >= 0				ifTrue: [^ 1.570796326794897 "90.0 degreesToRadians"]				ifFalse: [^ 4.71238898038469 "270.0 degreesToRadians"]]		ifFalse: 			[tan := y asFloat / x asFloat.			theta := tan arcTan.			x >= 0				ifTrue: [y >= 0						ifTrue: [^theta]						ifFalse: [^"360.0 degreesToRadians" 6.283185307179586 + theta]]				ifFalse: [^"180.0 degreesToRadians" 3.141592653589793 + theta]]! !!Point methodsFor: 'printing' stamp: 'BenjaminVanRyseghem 3/4/2011 13:48'!printOn: aStream 	"The receiver prints on aStream in terms of infix notation."	x printOn: aStream.	aStream nextPut: $@.	(y notNil and: [y negative])		ifTrue: [			"Avoid ambiguous @- construct"			aStream space].	y printOn: aStream! !!Point methodsFor: 'printing' stamp: 'ar 7/8/2006 19:15'!storeOn: aStream 	"x@y printed form is good for storing too"	aStream nextPut: $(.	self printOn: aStream.	aStream nextPut: $).! !!Point methodsFor: 'self evaluating' stamp: 'sd 7/31/2005 21:48'!isSelfEvaluating	^ self class == Point! !!Point methodsFor: 'testing' stamp: 'ar 10/29/2000 19:02'!isZero	^x isZero and:[y isZero]! !!Point methodsFor: 'transforming' stamp: 'di 4/30/1998 11:16'!adhereTo: aRectangle	"If the receiver lies outside aRectangle, return the nearest point on the boundary of the rectangle, otherwise return self."	(aRectangle containsPoint: self) ifTrue: [^ self].	^ ((x max: aRectangle left) min: aRectangle right)		@ ((y max: aRectangle top) min: aRectangle bottom)! !!Point methodsFor: 'transforming' stamp: 'ar 8/26/2001 22:14'!negated	"Answer a point whose x and y coordinates are the negatives of those of the receiver.  6/6/96 sw"	"Optimized for speed -- ar 8/26/2001"	^ (0 - x) @ (0 - y)! !!Point methodsFor: 'transforming' stamp: 'lr 7/4/2009 10:42'!rotateBy: angle about: center 	"Even though Point.theta is measured CW, this rotates with the more conventional CCW interpretateion of angle."	| p r theta |	p := self - center.	r := p r.	theta := angle asFloat - p theta.	^ (center x asFloat + (r * theta cos)) @ (center y asFloat - (r * theta sin))! !!Point methodsFor: 'transforming'!scaleBy: factor 	"Answer a Point scaled by factor (an instance of Point)."	^(factor x * x) @ (factor y * y)! !!Point methodsFor: 'transforming' stamp: 'di 12/4/97 14:34'!scaleFrom: rect1 to: rect2	"Produce a point stretched according to the stretch from rect1 to rect2"	^ rect2 topLeft + (((x-rect1 left) * rect2 width // rect1 width)					@ ((y-rect1 top) * rect2 height // rect1 height))! !!Point methodsFor: 'transforming'!translateBy: delta 	"Answer a Point translated by delta (an instance of Point)."	^(delta x + x) @ (delta y + y)! !!Point methodsFor: 'truncation and round off' stamp: 'jm 6/3/1998 12:21'!rounded	"Answer a Point that is the receiver's x and y rounded. Answer the receiver if its coordinates are already integral."	(x isInteger and: [y isInteger]) ifTrue: [^ self].	^ x rounded @ y rounded! !!Point methodsFor: 'truncation and round off' stamp: 'nice 2/5/2006 16:35'!roundTo: grid	"Answer a Point that is the receiver's x and y rounded to grid x and 	grid y."		| gridPoint |	gridPoint := grid asPoint.	^(x roundTo: gridPoint x) @ (y roundTo: gridPoint y)! !!Point methodsFor: 'truncation and round off' stamp: 'lr 7/4/2009 10:42'!truncateTo: grid 	"Answer a Point that is the receiver's x and y truncated to grid x and 	grid y."	| gridPoint |	gridPoint := grid asPoint.	^ (x truncateTo: gridPoint x) @ (y truncateTo: gridPoint y)! !!Point methodsFor: 'truncation and round off' stamp: 'jm 5/29/1998 15:53'!truncated	"Answer a Point whose x and y coordinates are integers. Answer the receiver if its coordinates are already integral."	(x isInteger and: [y isInteger]) ifTrue: [^ self].	^ x truncated @ y truncated! !!Point methodsFor: 'truncation and roundoff' stamp: 'nice 2/5/2006 16:43'!ceiling	"Answer a Point that is the receiver's x and y ceiling. Answer the receiver if its coordinates are already integral."	(x isInteger and: [y isInteger]) ifTrue: [^ self].	^ x ceiling @ y ceiling! !!Point methodsFor: 'truncation and roundoff' stamp: 'nice 2/5/2006 16:43'!floor	"Answer a Point that is the receiver's x and y floor. Answer the receiver if its coordinates are already integral."	(x isInteger and: [y isInteger]) ifTrue: [^ self].	^ x floor @ y floor! !!Point methodsFor: 'truncation and roundoff' stamp: 'wiz 1/11/2006 18:32'!isIntegerPoint^ x isInteger and: [ y isInteger ] ! !!Point methodsFor: 'truncation and roundoff' stamp: 'nice 2/5/2006 16:42'!roundDownTo: grid	"Answer a Point that is the receiver's x and y rounded to grid x and 	grid y by lower value (toward negative infinity)."		| gridPoint |	gridPoint := grid asPoint.	^(x roundDownTo: gridPoint x) @ (y roundDownTo: gridPoint y)! !!Point methodsFor: 'truncation and roundoff' stamp: 'nice 2/5/2006 16:41'!roundUpTo: grid	"Answer a Point that is the receiver's x and y rounded to grid x and 	grid y by upper value (toward infinity)."		| gridPoint |	gridPoint := grid asPoint.	^(x roundUpTo: gridPoint x) @ (y roundUpTo: gridPoint y)! !!Point methodsFor: 'private' stamp: 'lr 7/4/2009 10:42'!bitShiftPoint: bits 	x := x bitShift: bits.	y := y bitShift: bits! !!Point methodsFor: 'private' stamp: 'lr 7/4/2009 10:42'!setR: rho degrees: degrees 	| radians |	radians := degrees asFloat degreesToRadians.	x := rho asFloat * radians cos.	y := rho asFloat * radians sin! !!Point methodsFor: 'private' stamp: 'lr 7/4/2009 10:42'!setX: xValue setY: yValue 	x := xValue.	y := yValue! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Point class	instanceVariableNames: ''!!Point class methodsFor: '*System-Settings-Browser' stamp: 'alain.plantec 4/21/2009 09:57'!settingInputWidgetForNode: aSettingNode	^ aSettingNode inputWidgetForPoint! !!Point class methodsFor: 'instance creation' stamp: 'sw 9/20/97 15:34'!fromUser	Sensor waitNoButton.	Cursor crossHair show.	Sensor waitButton.	Cursor normal show.	^ Sensor cursorPoint"Point fromUser"! !!Point class methodsFor: 'instance creation' stamp: 'wiz 5/4/2006 00:04'!fromUserWithCursor: aCursor	Sensor waitNoButton.	aCursor showWhile:[Sensor waitButton].	^ Sensor cursorPoint"Point fromUserWithCursor: Cursor target"! !!Point class methodsFor: 'instance creation' stamp: 'md 12/2/2004 23:44'!r: rho degrees: degrees	"Answer an instance of me with polar coordinates rho and theta."	^self basicNew setR: rho degrees: degrees! !!Point class methodsFor: 'instance creation' stamp: 'md 12/2/2004 23:44'!x: xInteger y: yInteger 	"Answer an instance of me with coordinates xInteger and yInteger."	^self basicNew setX: xInteger setY: yInteger! !